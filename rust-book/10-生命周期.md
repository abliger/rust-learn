# 生命周期

还记得在第三章结构体曾说过,那处用 String 而不用 &str 是因为引用内容可能为空吗?生命周期就可以解决这种问题.即解决悬垂引用.

## 生命周期注解语法

```rust
&i32        // 引用
&'a i32     // 带有显式生命周期的引用
&'a mut i32 // 带有显式生命周期的可变引用
```

只有引用需要添加生命周期.其他的看所有权.

## 函数的泛型生命周期

对于这个函数,编译不能通过:

```rust
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

rust 编译程序会告诉我们需要添加生命周期.

因为我们需要 x 、y 和返回值存活一样久.所以都添加 'a 生命周期.

当具体的引用被传递给 longest 时,被 'a 所替代的具体生命周期是 x 的作用域与 y 的作用域相重叠的那一部分.换一种说法就是泛型生命周期 'a 的具体生命周期等同于 x 和 y 的生命周期中较小的那一个.因为我们用相同的生命周期参数 'a 标注了返回的引用值,所以返回的引用值就能保证在 x 和 y 中较短的那个生命周期结束之前保持有效.

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

> 注意:
>
> 1. 记住通过在函数签名中指定生命周期参数时,我们并没有改变任何传入值或返回值的生命周期,而是指出任何不满足这个约束条件的值都将被借用检查器拒绝.
> 2. 当在函数中使用生命周期注解时,这些注解出现在函数签名中,而不存在于函数体中的任何代码中.生命周期注解成为了函数约定的一部分.
> 3. 生命周期语法是用于将函数的多个参数与其返回值的生命周期进行关联的.一旦他们形成了某种关联,Rust 就有了足够的信息来允许内存安全的操作并阻止会产生悬垂指针亦或是违反内存安全的行为.
>
> 下面的代码就不能通过编译
>
> ```rust
> fn longest<'a>(x: &str, y: &str) -> &'a str {
>    let result = String::from("really long string");
>    result.as_str()
> }
> ```
>
> 返回值是引用,参数也都是引用.至少要有一个参数的生命周期和返回值相同

## 结构体中的生命周期

全部包含所有权类型的结构体不需要生命周期,只有成员有引用类型的结构体需要为每一个引用添加生命周期.

## 静态生命周期

静态生命周期 符号 'static .其生命周期存活于整个程序间.

所有的字符串字面值的生命周期都是静态生命周期.

```rust
let s: &'static str = "I have a static lifetime.";
```

## 结合泛型类型参数、trait bounds 和生命周期

```rust
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

## 生命周期的省略

1. 编译器为每一个是引用参数都分配了一个生命周期参数
2. 如果只有一个输入生命周期参数,那么它被赋予所有输出生命周期参数: `fn foo<'a>(x: &'a i32) -> &'a i32`
3. 如果方法有多个输入生命周期参数并且其中一个参数是 &self 或 &mut self,说明是个对象的方法(method),那么所有输出生命周期参数被赋予 self 的生命周期.

## 为带有生命周期结构体实现方法

```rust
impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
```

impl 之后和类型名称之后的生命周期参数是必要的,不过因为第一条生命周期规则我们并不必须标注 self 引用的生命周期.

如果是关联函数,需要看返回引用和参数引用的生命周期是否是该结构体的生命周期.如果不是需要在 impl 后加入新的生命周期标记 如 'b.
